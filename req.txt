from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Sessin
from app.database.database import get_db
from app.schemas.schemas import TaskCreate, TaskUpdate, TaskOut
from app.models.models import Task
from typing import List, Optional

router = APIRouter()

STATUS_FLOW = ["not_started", "pending", "in_progress", "completed"]


# ✅ CREATE Task
@router.post("/", response_model=TaskOut, status_code=201)
def create_task(task_data: TaskCreate, db: Session = Depends(get_db)):
    try:
        # Validate status
        if task_data.status not in STATUS_FLOW:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid status value. Allowed values are: {', '.join(STATUS_FLOW)}"
            )

        # Create new task
        task = Task(**task_data.model_dump())
        db.add(task)
        db.commit()
        db.refresh(task)
        return task

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An unexpected error occurred while creating the task. Please try again later."
        )


# ✅ GET & GET BY ID Combined
@router.get("/", response_model=List[TaskOut])
def get_tasks(
    db: Session = Depends(get_db),
    task_id: Optional[int] = Query(default=None, description="Optional Task ID to fetch a specific task")
):
    try:
        if task_id:
            task = db.query(Task).filter(Task.id == task_id).first()
            if not task:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail=f"No task found with ID {task_id}."
                )
            return [task]  # returning a list for consistent response_model type

        tasks = db.query(Task).order_by(Task.id).all()
        if not tasks:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="No tasks available."
            )
        return tasks

    except HTTPException as e:
        raise e
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Unable to fetch tasks. Please try again later."
        )


# ✅ UPDATE Task (with cyclic flow validation)
@router.put("/{task_id}", response_model=TaskOut)
def update_task(task_id: int, update_data: TaskUpdate, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Task with ID {task_id} not found."
            )

        # Enforce cyclic flow if status is being updated
        if update_data.status:
            current_status = task.status
            new_status = update_data.status

            if current_status not in STATUS_FLOW or new_status not in STATUS_FLOW:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid status. Allowed values are: {', '.join(STATUS_FLOW)}"
                )

            current_index = STATUS_FLOW.index(current_status)
            new_index = STATUS_FLOW.index(new_status)

            if new_index < current_index:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid status transition. Cannot move backward from '{current_status}' to '{new_status}'."
                )

        update_dict = update_data.model_dump(exclude_unset=True)
        for key, value in update_dict.items():
            setattr(task, key, value)

        db.commit()
        db.refresh(task)
        return task

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Something went wrong while updating the task. Please try again later."
        )


# ✅ DELETE Task
@router.delete("/{task_id}", status_code=200)
def delete_task(task_id: int, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Task with ID {task_id} not found."
            )

        db.delete(task)
        db.commit()
        return {"message": f"Task with ID {task_id} deleted successfully."}

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete the task due to an internal error. Please try again later."

        )



# app/exceptions/handlers.py
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from typing import Any, Dict

class CustomHTTPException(Exception):
    def __init__(self, status_code: int, detail: str, headers: Dict[str, Any] = None):
        self.status_code = status_code
        self.detail = detail
        self.headers = headers

class TaskNotFoundError(CustomHTTPException):
    def __init__(self, task_id: int):
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Task with ID {task_id} not found."
        )

class InvalidStatusTransitionError(CustomHTTPException):
    def __init__(self, current_status: str, new_status: str):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f'Invalid status transition. Cannot move backward from "{current_status}" to "{new_status}"'
        )

class InvalidStatusError(CustomHTTPException):
    def __init__(self, status_value: str, allowed_values: list):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid status value '{status_value}'. Allowed values are: {', '.join(allowed_values)}"
        )

class EmptyTitleError(CustomHTTPException):
    def __init__(self):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Title cannot be empty or contain only whitespace"
        )

class DatabaseError(CustomHTTPException):
    def __init__(self, operation: str):
        super().__init__(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Database error during {operation}. Please try again later."
        )

def setup_exception_handlers(app: FastAPI):
    
    @app.exception_handler(CustomHTTPException)
    async def custom_http_exception_handler(request: Request, exc: CustomHTTPException):
        return JSONResponse(
            status_code=exc.status_code,
            content={
                "success": False,
                "error": {
                    "code": exc.__class__.__name__,
                    "message": exc.detail,
                    "path": request.url.path
                }
            },
            headers=exc.headers
        )
    
    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        errors = []
        for error in exc.errors():
            errors.append({
                "field": " -> ".join(str(loc) for loc in error['loc']),
                "message": error['msg'],
                "type": error['type']
            })
        
        return JSONResponse(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            content={
                "success": False,
                "error": {
                    "code": "VALIDATION_ERROR",
                    "message": "Request validation failed",
                    "details": errors
                }
            }
        )
    
    @app.exception_handler(SQLAlchemyError)
    async def sqlalchemy_exception_handler(request: Request, exc: SQLAlchemyError):
        # Log the actual error for debugging
        print(f"Database error: {str(exc)}")
        
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "success": False,
                "error": {
                    "code": "DATABASE_ERROR",
                    "message": "A database error occurred",
                    "path": request.url.path
                }
            }
        )
    
    @app.exception_handler(IntegrityError)
    async def integrity_error_handler(request: Request, exc: IntegrityError):
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content={
                "success": False,
                "error": {
                    "code": "INTEGRITY_ERROR",
                    "message": "Data integrity violation (e.g., duplicate entry, foreign key constraint)",
                    "path": request.url.path
                }
            }
        )
    
    @app.exception_handler(500)
    @app.exception_handler(Exception)
    async def general_exception_handler(request: Request, exc: Exception):
        # Log the full exception for debugging
        print(f"Unexpected error: {str(exc)}")
        
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "success": False,
                "error": {
                    "code": "INTERNAL_SERVER_ERROR",
                    "message": "An unexpected error occurred",
                    "path": request.url.path
                }
            }
        )


# app/database/database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.exc import SQLAlchemyError
from app.config.settings import settings
from app.exceptions.handlers import DatabaseError
import logging

logger = logging.getLogger(__name__)

SQLALCHEMY_DATABASE_URL = settings.DATABASE_URL

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, 
    connect_args={"check_same_thread": False},
    pool_pre_ping=True,  # Check connection before using
    echo=settings.DEBUG   # Log SQL queries in debug mode
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
        db.commit()
    except SQLAlchemyError as e:
        logger.error(f"Database error: {str(e)}")
        db.rollback()
        raise DatabaseError("database operation") from e
    except Exception as e:
        logger.error(f"Unexpected error in database session: {str(e)}")
        db.rollback()
        raise
    finally:
        db.close()


# app/models/models.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, CheckConstraint
from sqlalchemy.sql import func
from app.database.database import Base

class Task(Base):
    __tablename__ = "tasks"

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    title = Column(String(200), index=True, nullable=False)  # Added length constraint
    description = Column(String(1000), nullable=True)  # Added length constraint
    completed = Column(Boolean, default=False)
    status = Column(String(20), default="pending", nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    # Database-level constraints
    __table_args__ = (
        CheckConstraint(
            "status IN ('not_started', 'pending', 'in_progress', 'completed')",
            name='valid_status_check'
        ),
        CheckConstraint(
            "length(trim(title)) > 0",
            name='non_empty_title_check'
        ),
    )




# app/routers/tasks.py
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from app.database.database import get_db
from app.schemas.schemas import TaskCreate, TaskUpdate, TaskOut
from app.models.models import Task
from app.exceptions.handlers import (
    TaskNotFoundError, InvalidStatusTransitionError, 
    InvalidStatusError, EmptyTitleError, DatabaseError
)
from typing import List, Optional
import logging

logger = logging.getLogger(__name__)

router = APIRouter()

STATUS_FLOW = ["not_started", "pending", "in_progress", "completed"]

def validate_task_data(task_data: TaskCreate) -> None:
    """Validate task data before database operations"""
    # Title validation
    if not task_data.title or not task_data.title.strip():
        raise EmptyTitleError()
    
    # Title length validation
    if len(task_data.title.strip()) > 200:
        raise InvalidStatusError(
            "Title too long", 
            ["Title must be less than 200 characters"]
        )
    
    # Status validation
    if task_data.status and task_data.status not in STATUS_FLOW:
        raise InvalidStatusError(task_data.status, STATUS_FLOW)

def validate_status_transition(current_status: str, new_status: str) -> None:
    """Validate status transition follows the correct flow"""
    if new_status not in STATUS_FLOW:
        raise InvalidStatusError(new_status, STATUS_FLOW)
    
    current_index = STATUS_FLOW.index(current_status)
    new_index = STATUS_FLOW.index(new_status)
    
    if new_index < current_index:
        raise InvalidStatusTransitionError(current_status, new_status)

# CREATE Task
@router.post('/', response_model=TaskOut, status_code=201)
def create_task(task_data: TaskCreate, db: Session = Depends(get_db)):
    try:
        # Validate input data
        validate_task_data(task_data)
        
        # Create new task
        task = Task(**task_data.model_dump())
        db.add(task)
        db.commit()
        db.refresh(task)
        
        logger.info(f"Task created successfully with ID: {task.id}")
        return task
        
    except (EmptyTitleError, InvalidStatusError):
        db.rollback()
        raise
    except IntegrityError as e:
        db.rollback()
        logger.error(f"Integrity error while creating task: {str(e)}")
        raise DatabaseError("task creation - possible duplicate or constraint violation")
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Database error while creating task: {str(e)}")
        raise DatabaseError("task creation")
    except Exception as e:
        db.rollback()
        logger.error(f"Unexpected error while creating task: {str(e)}")
        raise

# GET Tasks
@router.get("/", response_model=List[TaskOut])
def get_tasks(
    db: Session = Depends(get_db),
    task_id: Optional[int] = Query(default=None, description='Optional Task ID to fetch a specific task'),
    status: Optional[str] = Query(default=None, description='Filter by status'),
    skip: int = Query(0, ge=0, description='Number of records to skip'),
    limit: int = Query(100, ge=1, le=1000, description='Number of records to return')
):
    try:
        # Validate status filter if provided
        if status and status not in STATUS_FLOW:
            raise InvalidStatusError(status, STATUS_FLOW)
        
        if task_id:
            task = db.query(Task).filter(Task.id == task_id).first()
            if not task:
                raise TaskNotFoundError(task_id)
            return [task]
        
        # Build query with filters
        query = db.query(Task)
        if status:
            query = query.filter(Task.status == status)
        
        tasks = query.order_by(Task.id).offset(skip).limit(limit).all()
        
        if not tasks and (task_id is not None or status is not None):
            raise TaskNotFoundError(task_id if task_id else 0)
            
        return tasks
        
    except (TaskNotFoundError, InvalidStatusError):
        raise
    except SQLAlchemyError as e:
        logger.error(f"Database error while fetching tasks: {str(e)}")
        raise DatabaseError("fetching tasks")
    except Exception as e:
        logger.error(f"Unexpected error while fetching tasks: {str(e)}")
        raise

# UPDATE Task
@router.put("/{task_id}", response_model=TaskOut)
def update_task(task_id: int, update_data: TaskUpdate, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise TaskNotFoundError(task_id)
        
        # Validate title if provided
        if update_data.title is not None:
            if not update_data.title.strip():
                raise EmptyTitleError()
            if len(update_data.title.strip()) > 200:
                raise InvalidStatusError(
                    "Title too long", 
                    ["Title must be less than 200 characters"]
                )
        
        # Validate status transition if status is being updated
        if update_data.status is not None and update_data.status != task.status:
            validate_status_transition(task.status, update_data.status)
        
        # Update task
        update_dict = update_data.model_dump(exclude_unset=True)
        for key, value in update_dict.items():
            setattr(task, key, value)
        
        db.commit()
        db.refresh(task)
        
        logger.info(f"Task with ID {task_id} updated successfully")
        return task
        
    except (TaskNotFoundError, EmptyTitleError, InvalidStatusError, InvalidStatusTransitionError):
        db.rollback()
        raise
    except IntegrityError as e:
        db.rollback()
        logger.error(f"Integrity error while updating task {task_id}: {str(e)}")
        raise DatabaseError("task update - possible constraint violation")
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Database error while updating task {task_id}: {str(e)}")
        raise DatabaseError("task update")
    except Exception as e:
        db.rollback()
        logger.error(f"Unexpected error while updating task {task_id}: {str(e)}")
        raise

# DELETE Task
@router.delete("/{task_id}", status_code=200)
def delete_task(task_id: int, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise TaskNotFoundError(task_id)
        
        db.delete(task)
        db.commit()
        
        logger.info(f"Task with ID {task_id} deleted successfully")
        return {
            "success": True,
            "message": f"Task with ID {task_id} deleted successfully."
        }
        
    except TaskNotFoundError:
        db.rollback()
        raise
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Database error while deleting task {task_id}: {str(e)}")
        raise DatabaseError("task deletion")
    except Exception as e:
        db.rollback()
        logger.error(f"Unexpected error while deleting task {task_id}: {str(e)}")
        raise


# app/main.py
import uvicorn
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from app.config.settings import settings
from app.database.database import Base, engine, get_db
from app.routers import tasks
from app.models.models import Task
from app.exceptions.handlers import setup_exception_handlers
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Create database tables
try:
    Base.metadata.create_all(bind=engine)
    logging.info("Database tables created successfully")
except Exception as e:
    logging.error(f"Failed to create database tables: {str(e)}")
    raise

app = FastAPI(
    title=settings.APP_NAME,
    version=settings.API_VERSION,
    debug=settings.DEBUG
)

# Setup exception handlers
setup_exception_handlers(app)

# Include router
app.include_router(
    tasks.router,
    prefix=f"/api/{settings.API_VERSION}/tasks",
    tags=["Tasks"]
)

@app.get("/health")
def health_check():
    return {
        "success": True,
        "status": "ok", 
        "message": "FastAPI server is running",
        "version": settings.API_VERSION
    }

@app.get("/")
def get_all_tasks(db: Session = Depends(get_db)):
    try:
        tasks = db.query(Task).all()
        return {
            "success": True,
            "data": tasks if tasks else [],
            "message": "No tasks found. Add some using /docs or /tasks" if not tasks else "Tasks retrieved successfully"
        }
    except Exception as e:
        logging.error(f"Error in root endpoint: {str(e)}")
        return {
            "success": False,
            "error": "Failed to fetch tasks",
            "data": []
        }

if __name__ == "__main__":
    uvicorn.run(
        app, 
        host="0.0.0.0", 
        port=8000,
        log_level="info"
    )





















import uvicorn
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from app.config.settings import settings
from app.database.database import Base, engine, get_db
from app.routers.tasks import router as tasks_router
from app.models.models import Task
from app.exceptions.handlers import setup_exception_handlers

# Create database tables
Base.metadata.create_all(bind=engine)

app = FastAPI(
    title=settings.APP_NAME,
    version=settings.API_VERSION,
    description="A complete Task Management API with proper error handling and validation",
    debug=settings.DEBUG
)

# Setup exception handlers
setup_exception_handlers(app)

# Include router
app.include_router(
    tasks_router,
    prefix=f"/api/{settings.API_VERSION}/tasks",
    tags=["Tasks"]
)

@app.get("/health")
def health_check():
    return {
        "success": True,
        "status": "ok", 
        "message": "FastAPI server is running",
        "version": settings.API_VERSION
    }

@app.get("/")
def get_all_tasks(db: Session = Depends(get_db)):
    try:
        tasks = db.query(Task).all()
        if not tasks:
            return {
                "success": True,
                "message": "Welcome to Task Management API! No tasks found. Add some using the /docs endpoint.",
                "docs_url": "/docs"
            }
        return {
            "success": True,
            "data": tasks,
            "count": len(tasks)
        }
    except Exception:
        return {
            "success": False,
            "error": "Failed to fetch tasks",
            "data": []
        }

if __name__ == "__main__":
    uvicorn.run(
        "app.main:app", 
        host="0.0.0.0", 
        port=8000,
        reload=settings.DEBUG
    )

from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from app.database.database import get_db
from app.schemas.schemas import TaskCreate, TaskUpdate, TaskResponse
from app.models.models import Task
from app.utils.enums import validate_status_transition, validate_status_value
from app.exceptions.handlers import (
    TaskNotFoundError, InvalidStatusTransitionError, 
    InvalidStatusError, EmptyTitleError, DatabaseError
)
from typing import List, Optional

router = APIRouter()

def validate_task_update_data(update_data: TaskUpdate) -> None:
    if update_data.title is not None:
        if not update_data.title.strip():
            raise EmptyTitleError()
        if len(update_data.title.strip()) > 200:
            raise InvalidStatusError(
                "Title too long", 
                ["Title must be less than 200 characters"]
            )

# CREATE Task
@router.post('/', response_model=TaskResponse, status_code=201)
def create_task(task_data: TaskCreate, db: Session = Depends(get_db)):
    try:
        task_dict = task_data.model_dump()
        task = Task(**task_dict)
        
        db.add(task)
        db.commit()
        db.refresh(task)
        return task
        
    except (EmptyTitleError, InvalidStatusError):
        db.rollback()
        raise
    except IntegrityError:
        db.rollback()
        raise DatabaseError("task creation - possible duplicate or constraint violation")
    except SQLAlchemyError:
        db.rollback()
        raise DatabaseError("task creation")
    except Exception:
        db.rollback()
        raise

# GET Tasks
@router.get("/", response_model=List[TaskResponse])
def get_tasks(
    db: Session = Depends(get_db),
    task_id: Optional[int] = Query(default=None, description='Optional Task ID to fetch a specific task'),
    status: Optional[str] = Query(default=None, description='Filter by status'),
    skip: int = Query(0, ge=0, description='Number of records to skip'),
    limit: int = Query(100, ge=1, le=1000, description='Number of records to return')
):
    try:
        if status:
            validate_status_value(status)
        
        if task_id:
            task = db.query(Task).filter(Task.id == task_id).first()
            if not task:
                raise TaskNotFoundError(task_id)
            return [task]
        
        query = db.query(Task)
        if status:
            status_enum = validate_status_value(status)
            query = query.filter(Task.status == status_enum)
        
        tasks = query.order_by(Task.id).offset(skip).limit(limit).all()
        
        if not tasks and (task_id is not None or status is not None):
            raise TaskNotFoundError(task_id if task_id else 0)
            
        return tasks
        
    except (TaskNotFoundError, InvalidStatusError):
        raise
    except SQLAlchemyError:
        raise DatabaseError("fetching tasks")
    except Exception:
        raise

# UPDATE Task
@router.put("/{task_id}", response_model=TaskResponse)
def update_task(task_id: int, update_data: TaskUpdate, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise TaskNotFoundError(task_id)
        
        validate_task_update_data(update_data)
        
        if update_data.status is not None and update_data.status != task.status.value:
            validate_status_transition(task.status.value, update_data.status)
        
        update_dict = update_data.model_dump(exclude_unset=True)
        for key, value in update_dict.items():
            setattr(task, key, value)
        
        db.commit()
        db.refresh(task)
        return task
        
    except (TaskNotFoundError, EmptyTitleError, InvalidStatusError, InvalidStatusTransitionError):
        db.rollback()
        raise
    except IntegrityError:
        db.rollback()
        raise DatabaseError("task update - possible constraint violation")
    except SQLAlchemyError:
        db.rollback()
        raise DatabaseError("task update")
    except Exception:
        db.rollback()
        raise

# DELETE Task
@router.delete("/{task_id}", status_code=200)
def delete_task(task_id: int, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise TaskNotFoundError(task_id)
        
        db.delete(task)
        db.commit()
        return {
            "success": True,
            "message": f"Task with ID {task_id} deleted successfully."
        }
        
    except TaskNotFoundError:
        db.rollback()
        raise
    except SQLAlchemyError:
        db.rollback()
        raise DatabaseError("task deletion")
    except Exception:
        db.rollback()
        raise






from pydantic import BaseModel, Field, validator
from typing import Optional
from datetime import datetime
from app.utils.enums import TaskStatus, validate_status_value
from app.exceptions.handlers import InvalidStatusError, EmptyTitleError

class TaskBase(BaseModel):
    title: str = Field(..., min_length=1, max_length=200, description="Task title")
    description: Optional[str] = Field(None, max_length=1000, description="Task description")
    status: str = Field(default="not_started", description="Task status")

    @validator('status')
    def validate_status(cls, v):
        if v is None:
            return "not_started"
        
        try:
            validate_status_value(v)
            return v
        except InvalidStatusError:
            raise

    @validator('title')
    def validate_title(cls, v):
        if not v or not v.strip():
            raise EmptyTitleError()
        return v.strip()

class TaskCreate(TaskBase):
    pass

class TaskUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=200, description="Task title")
    description: Optional[str] = Field(None, max_length=1000, description="Task description")
    completed: Optional[bool] = Field(None, description="Whether task is completed")
    status: Optional[str] = Field(None, description="Task status")

    @validator('status')
    def validate_status(cls, v):
        if v is None:
            return None
        
        try:
            validate_status_value(v)
            return v
        except InvalidStatusError:
            raise

    @validator('title')
    def validate_title(cls, v):
        if v is not None:
            if not v.strip():
                raise EmptyTitleError()
            return v.strip()
        return v

class TaskResponse(TaskBase):
    id: int
    completed: bool
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True






from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from typing import Any, Dict

class CustomHTTPException(Exception):
    def __init__(self, status_code: int, detail: str, headers: Dict[str, Any] = None):
        self.status_code = status_code
        self.detail = detail
        self.headers = headers

class TaskNotFoundError(CustomHTTPException):
    def __init__(self, task_id: int):
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Task with ID {task_id} not found."
        )

class InvalidStatusTransitionError(CustomHTTPException):
    def __init__(self, current_status: str, new_status: str):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f'Invalid status transition. Cannot move backward from "{current_status}" to "{new_status}". Allowed workflow: not_started → pending → in_progress → completed'
        )

class InvalidStatusError(CustomHTTPException):
    def __init__(self, status_value: str, allowed_values: list):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid status '{status_value}'. Must be one of: {', '.join(allowed_values)}"
        )

class EmptyTitleError(CustomHTTPException):
    def __init__(self):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Title cannot be empty or contain only whitespace"
        )

class DatabaseError(CustomHTTPException):
    def __init__(self, operation: str):
        super().__init__(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Database error during {operation}. Please try again later."
        )

def setup_exception_handlers(app: FastAPI):
    
    @app.exception_handler(CustomHTTPException)
    async def custom_http_exception_handler(request: Request, exc: CustomHTTPException):
        return JSONResponse(
            status_code=exc.status_code,
            content={
                "success": False,
                "error": {
                    "code": exc.__class__.__name__,
                    "message": exc.detail,
                    "path": request.url.path
                }
            },
            headers=exc.headers
        )
    
    @app.exception_handler(InvalidStatusError)
    async def invalid_status_handler(request: Request, exc: InvalidStatusError):
        return JSONResponse(
            status_code=exc.status_code,
            content={
                "success": False,
                "error": {
                    "code": "INVALID_STATUS",
                    "message": exc.detail,
                    "path": request.url.path
                }
            },
            headers=exc.headers
        )
    
    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        errors = []
        for error in exc.errors():
            field_path = " -> ".join(str(loc) for loc in error['loc'])
            
            if error['type'] == 'value_error':
                if 'enum' in error.get('ctx', {}):
                    errors.append({
                        "field": field_path,
                        "message": f"Invalid value. Must be one of: {', '.join(error['ctx']['expected'])}",
                        "type": "invalid_choice"
                    })
                else:
                    errors.append({
                        "field": field_path,
                        "message": error['msg'],
                        "type": error['type']
                    })
            elif error['type'] == 'string_too_long':
                errors.append({
                    "field": field_path,
                    "message": f"Value too long. Maximum length is {error['ctx']['max_length']} characters",
                    "type": "length_exceeded"
                })
            elif error['type'] == 'string_too_short':
                errors.append({
                    "field": field_path,
                    "message": f"Value too short. Minimum length is {error['ctx']['min_length']} characters",
                    "type": "too_short"
                })
            elif error['type'] == 'missing':
                errors.append({
                    "field": field_path,
                    "message": "This field is required",
                    "type": "required_field"
                })
            else:
                errors.append({
                    "field": field_path,
                    "message": error['msg'],
                    "type": error['type']
                })
        
        return JSONResponse(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            content={
                "success": False,
                "error": {
                    "code": "VALIDATION_ERROR",
                    "message": "Please check your input data",
                    "details": errors
                }
            }
        )
    
    @app.exception_handler(SQLAlchemyError)
    async def sqlalchemy_exception_handler(request: Request, exc: SQLAlchemyError):
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "success": False,
                "error": {
                    "code": "DATABASE_ERROR",
                    "message": "A database error occurred",
                    "path": request.url.path
                }
            }
        )
    
    @app.exception_handler(IntegrityError)
    async def integrity_error_handler(request: Request, exc: IntegrityError):
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content={
                "success": False,
                "error": {
                    "code": "INTEGRITY_ERROR",
                    "message": "Data integrity violation",
                    "path": request.url.path
                }
            }
        )
    
    @app.exception_handler(Exception)
    async def general_exception_handler(request: Request, exc: Exception):
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "success": False,
                "error": {
                    "code": "INTERNAL_SERVER_ERROR",
                    "message": "An unexpected error occurred",
                    "path": request.url.path
                }
            }
        )





from enum import Enum
from typing import List
from app.exceptions.handlers import InvalidStatusTransitionError, InvalidStatusError

class TaskStatus(str, Enum):
    NOT_STARTED = "not_started"
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"

STATUS_WORKFLOW: List[TaskStatus] = [
    TaskStatus.NOT_STARTED,
    TaskStatus.PENDING,
    TaskStatus.IN_PROGRESS,
    TaskStatus.COMPLETED
]

def validate_status_value(status_value: str) -> TaskStatus:
    try:
        return TaskStatus(status_value)
    except ValueError:
        valid_values = [status.value for status in TaskStatus]
        raise InvalidStatusError(status_value, valid_values)

def validate_status_transition(current_status: str, new_status: str) -> None:
    current_enum = validate_status_value(current_status)
    new_enum = validate_status_value(new_status)
    
    current_index = STATUS_WORKFLOW.index(current_enum)
    new_index = STATUS_WORKFLOW.index(new_enum)
    
    if new_index < current_index:
        raise InvalidStatusTransitionError(current_status, new_status)




from sqlalchemy import Column, Integer, String, Boolean, DateTime, Enum, CheckConstraint
from sqlalchemy.sql import func
from app.database.database import Base
from app.utils.enums import TaskStatus

class Task(Base):
    __tablename__ = "tasks"

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    title = Column(String(200), index=True, nullable=False)
    description = Column(String(1000), nullable=True)
    completed = Column(Boolean, default=False)
    status = Column(Enum(TaskStatus), default=TaskStatus.NOT_STARTED, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    __table_args__ = (
        CheckConstraint(
            "length(trim(title)) > 0",
            name='non_empty_title_check'
        ),
    )



from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.exc import SQLAlchemyError
from app.config.settings import settings
from app.exceptions.handlers import DatabaseError

SQLALCHEMY_DATABASE_URL = settings.DATABASE_URL

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, 
    connect_args={"check_same_thread": False}
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
        db.commit()
    except SQLAlchemyError as e:
        db.rollback()
        raise DatabaseError("database operation")
    except Exception as e:
        db.rollback()
        raise
    finally:
        db.close()











-------_---------------
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from typing import Any, Dict

class CustomHTTPException(Exception):
    def __init__(self, status_code: int, detail: str, headers: Dict[str, Any] = None):
        self.status_code = status_code
        self.detail = detail
        self.headers = headers

class TaskNotFoundError(CustomHTTPException):
    def __init__(self, task_id: int):
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Task with ID {task_id} not found."
        )

class InvalidStatusTransitionError(CustomHTTPException):
    def __init__(self, current_status: str, new_status: str):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f'Invalid status transition. Cannot move backward from "{current_status}" to "{new_status}"'
        )

class InvalidStatusError(CustomHTTPException):
    def __init__(self, status_value: str, allowed_values: list):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid status value '{status_value}'. Allowed values are: {', '.join(allowed_values)}"
        )

class EmptyTitleError(CustomHTTPException):
    def __init__(self):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Title cannot be empty or contain only whitespace"
        )

class DatabaseError(CustomHTTPException):
    def __init__(self, operation: str):
        super().__init__(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Database error during {operation}. Please try again later."
        )

def setup_exception_handlers(app: FastAPI):
    
    @app.exception_handler(CustomHTTPException)
    async def custom_http_exception_handler(request: Request, exc: CustomHTTPException):
        return JSONResponse(
            status_code=exc.status_code,
            content={
                "success": False,
                "error": {
                    "code": exc.__class__.__name__,
                    "message": exc.detail,
                    "path": request.url.path
                }
            },
            headers=exc.headers
        )
    
    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        errors = []
        for error in exc.errors():
            errors.append({
                "field": " -> ".join(str(loc) for loc in error['loc']),
                "message": error['msg'],
                "type": error['type']
            })
        
        return JSONResponse(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            content={
                "success": False,
                "error": {
                    "code": "VALIDATION_ERROR",
                    "message": "Request validation failed",
                    "details": errors
                }
            }
        )
    
    @app.exception_handler(SQLAlchemyError)
    async def sqlalchemy_exception_handler(request: Request, exc: SQLAlchemyError):
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "success": False,
                "error": {
                    "code": "DATABASE_ERROR",
                    "message": "A database error occurred",
                    "path": request.url.path
                }
            }
        )
    
    @app.exception_handler(IntegrityError)
    async def integrity_error_handler(request: Request, exc: IntegrityError):
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content={
                "success": False,
                "error": {
                    "code": "INTEGRITY_ERROR",
                    "message": "Data integrity violation",
                    "path": request.url.path
                }
            }
        )
    
    @app.exception_handler(Exception)
    async def general_exception_handler(request: Request, exc: Exception):
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "success": False,
                "error": {
                    "code": "INTERNAL_SERVER_ERROR",
                    "message": "An unexpected error occurred",
                    "path": request.url.path
                }
            }
        )


from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.exc import SQLAlchemyError
from app.config.settings import settings
from app.exceptions.handlers import DatabaseError

SQLALCHEMY_DATABASE_URL = settings.DATABASE_URL

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, 
    connect_args={"check_same_thread": False}
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
        db.commit()
    except SQLAlchemyError as e:
        db.rollback()
        raise DatabaseError("database operation")
    except Exception as e:
        db.rollback()
        raise
    finally:
        db.close()



from sqlalchemy import Column, Integer, String, Boolean, DateTime, CheckConstraint
from sqlalchemy.sql import func
from app.database.database import Base

class Task(Base):
    __tablename__ = "tasks"

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    title = Column(String(200), index=True, nullable=False)
    description = Column(String(1000), nullable=True)
    completed = Column(Boolean, default=False)
    status = Column(String(20), default="pending", nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    __table_args__ = (
        CheckConstraint(
            "status IN ('not_started', 'pending', 'in_progress', 'completed')",
            name='valid_status_check'
        ),
        CheckConstraint(
            "length(trim(title)) > 0",
            name='non_empty_title_check'
        ),
    )


from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from app.database.database import get_db
from app.schemas.schemas import TaskCreate, TaskUpdate, TaskOut
from app.models.models import Task
from app.exceptions.handlers import (
    TaskNotFoundError, InvalidStatusTransitionError, 
    InvalidStatusError, EmptyTitleError, DatabaseError
)
from typing import List, Optional

router = APIRouter()

STATUS_FLOW = ["not_started", "pending", "in_progress", "completed"]

def validate_task_data(task_data: TaskCreate) -> None:
    if not task_data.title or not task_data.title.strip():
        raise EmptyTitleError()
    
    if len(task_data.title.strip()) > 200:
        raise InvalidStatusError(
            "Title too long", 
            ["Title must be less than 200 characters"]
        )
    
    if task_data.status and task_data.status not in STATUS_FLOW:
        raise InvalidStatusError(task_data.status, STATUS_FLOW)

def validate_status_transition(current_status: str, new_status: str) -> None:
    if new_status not in STATUS_FLOW:
        raise InvalidStatusError(new_status, STATUS_FLOW)
    
    current_index = STATUS_FLOW.index(current_status)
    new_index = STATUS_FLOW.index(new_status)
    
    if new_index < current_index:
        raise InvalidStatusTransitionError(current_status, new_status)

# CREATE Task
@router.post('/', response_model=TaskOut, status_code=201)
def create_task(task_data: TaskCreate, db: Session = Depends(get_db)):
    try:
        validate_task_data(task_data)
        
        task = Task(**task_data.model_dump())
        db.add(task)
        db.commit()
        db.refresh(task)
        return task
        
    except (EmptyTitleError, InvalidStatusError):
        db.rollback()
        raise
    except IntegrityError:
        db.rollback()
        raise DatabaseError("task creation - possible duplicate or constraint violation")
    except SQLAlchemyError:
        db.rollback()
        raise DatabaseError("task creation")
    except Exception:
        db.rollback()
        raise

# GET Tasks
@router.get("/", response_model=List[TaskOut])
def get_tasks(
    db: Session = Depends(get_db),
    task_id: Optional[int] = Query(default=None, description='Optional Task ID to fetch a specific task'),
    status: Optional[str] = Query(default=None, description='Filter by status'),
    skip: int = Query(0, ge=0, description='Number of records to skip'),
    limit: int = Query(100, ge=1, le=1000, description='Number of records to return')
):
    try:
        if status and status not in STATUS_FLOW:
            raise InvalidStatusError(status, STATUS_FLOW)
        
        if task_id:
            task = db.query(Task).filter(Task.id == task_id).first()
            if not task:
                raise TaskNotFoundError(task_id)
            return [task]
        
        query = db.query(Task)
        if status:
            query = query.filter(Task.status == status)
        
        tasks = query.order_by(Task.id).offset(skip).limit(limit).all()
        
        if not tasks and (task_id is not None or status is not None):
            raise TaskNotFoundError(task_id if task_id else 0)
            
        return tasks
        
    except (TaskNotFoundError, InvalidStatusError):
        raise
    except SQLAlchemyError:
        raise DatabaseError("fetching tasks")
    except Exception:
        raise

# UPDATE Task
@router.put("/{task_id}", response_model=TaskOut)
def update_task(task_id: int, update_data: TaskUpdate, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise TaskNotFoundError(task_id)
        
        if update_data.title is not None:
            if not update_data.title.strip():
                raise EmptyTitleError()
            if len(update_data.title.strip()) > 200:
                raise InvalidStatusError(
                    "Title too long", 
                    ["Title must be less than 200 characters"]
                )
        
        if update_data.status is not None and update_data.status != task.status:
            validate_status_transition(task.status, update_data.status)
        
        update_dict = update_data.model_dump(exclude_unset=True)
        for key, value in update_dict.items():
            setattr(task, key, value)
        
        db.commit()
        db.refresh(task)
        return task
        
    except (TaskNotFoundError, EmptyTitleError, InvalidStatusError, InvalidStatusTransitionError):
        db.rollback()
        raise
    except IntegrityError:
        db.rollback()
        raise DatabaseError("task update - possible constraint violation")
    except SQLAlchemyError:
        db.rollback()
        raise DatabaseError("task update")
    except Exception:
        db.rollback()
        raise

# DELETE Task
@router.delete("/{task_id}", status_code=200)
def delete_task(task_id: int, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise TaskNotFoundError(task_id)
        
        db.delete(task)
        db.commit()
        return {
            "success": True,
            "message": f"Task with ID {task_id} deleted successfully."
        }
        
    except TaskNotFoundError:
        db.rollback()
        raise
    except SQLAlchemyError:
        db.rollback()
        raise DatabaseError("task deletion")
    except Exception:
        db.rollback()
        raise


import uvicorn
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from app.config.settings import settings
from app.database.database import Base, engine, get_db
from app.routers import tasks
from app.models.models import Task
from app.exceptions.handlers import setup_exception_handlers

# Create database tables
Base.metadata.create_all(bind=engine)

app = FastAPI(
    title=settings.APP_NAME,
    version=settings.API_VERSION,
    debug=settings.DEBUG
)

# Setup exception handlers
setup_exception_handlers(app)

# Include router
app.include_router(
    tasks.router,
    prefix=f"/api/{settings.API_VERSION}/tasks",
    tags=["Tasks"]
)

@app.get("/health")
def health_check():
    return {
        "success": True,
        "status": "ok", 
        "message": "FastAPI server is running",
        "version": settings.API_VERSION
    }

@app.get("/")
def get_all_tasks(db: Session = Depends(get_db)):
    try:
        tasks = db.query(Task).all()
        return {
            "success": True,
            "data": tasks if tasks else [],
            "message": "No tasks found. Add some using /docs or /tasks" if not tasks else "Tasks retrieved successfully"
        }
    except Exception:
        return {
            "success": False,
            "error": "Failed to fetch tasks",
            "data": []
        }

if __name__ == "__main__":
    uvicorn.run(
        app, 
        host="0.0.0.0", 
        port=8000
    )


from pydantic import BaseModel, Field, validator
from typing import Optional
from datetime import datetime
from app.utils.enums import TaskStatus
from app.exceptions.handlers import InvalidStatusError, EmptyTitleError

class TaskBase(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    status: str = Field(default="not_started")

    @validator('status')
    def validate_status(cls, v):
        if v is None:
            return "not_started"
        
        if v not in ["not_started", "pending", "in_progress", "completed"]:
            raise InvalidStatusError(v, ["not_started", "pending", "in_progress", "completed"])
        return v

    @validator('title')
    def validate_title(cls, v):
        if not v or not v.strip():
            raise EmptyTitleError()
        return v.strip()

class TaskCreate(TaskBase):
    pass

class TaskUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    completed: Optional[bool] = None
    status: Optional[str] = None

    @validator('status')
    def validate_status(cls, v):
        if v is not None and v not in ["not_started", "pending", "in_progress", "completed"]:
            raise InvalidStatusError(v, ["not_started", "pending", "in_progress", "completed"])
        return v

    @validator('title')
    def validate_title(cls, v):
        if v is not None:
            if not v.strip():
                raise EmptyTitleError()
            return v.strip()
        return v

class TaskOut(TaskBase):
    id: int
    completed: bool
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True















without logging and using wnum ------
from enum import Enum
from typing import List
from app.exceptions.handlers import InvalidStatusError, InvalidStatusTransitionError

class TaskStatus(str, Enum):
    NOT_STARTED = "not_started"
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"

STATUS_WORKFLOW: List[TaskStatus] = [
    TaskStatus.NOT_STARTED,
    TaskStatus.PENDING,
    TaskStatus.IN_PROGRESS,
    TaskStatus.COMPLETED
]

def validate_status_value(status_value: str) -> TaskStatus:
    try:
        return TaskStatus(status_value)
    except ValueError:
        valid_values = [status.value for status in TaskStatus]
        raise InvalidStatusError(status_value, valid_values)

def validate_status_transition(current_status: str, new_status: str) -> None:
    current_enum = validate_status_value(current_status)
    new_enum = validate_status_value(new_status)
    
    current_index = STATUS_WORKFLOW.index(current_enum)
    new_index = STATUS_WORKFLOW.index(new_enum)
    
    if new_index < current_index:
        raise InvalidStatusTransitionError(current_status, new_status)


from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from app.database.database import get_db
from app.schemas.schemas import TaskCreate, TaskUpdate, TaskOut
from app.models.models import Task
from app.utils.enums import TaskStatus, STATUS_WORKFLOW, validate_status_value, validate_status_transition
from app.exceptions.handlers import (
    TaskNotFoundError, InvalidStatusTransitionError, 
    InvalidStatusError, EmptyTitleError, DatabaseError
)
from typing import List, Optional

router = APIRouter()

def validate_task_data(task_data: TaskCreate) -> None:
    if not task_data.title or not task_data.title.strip():
        raise EmptyTitleError()
    
    if len(task_data.title.strip()) > 200:
        raise InvalidStatusError(
            "Title too long", 
            ["Title must be less than 200 characters"]
        )
    
    # Status validation is handled by Pydantic validator with custom error

def validate_status_transition(current_status: str, new_status: str) -> None:
    # Convert strings to enums for workflow validation
    current_enum = validate_status_value(current_status)
    new_enum = validate_status_value(new_status)
    
    current_index = STATUS_WORKFLOW.index(current_enum)
    new_index = STATUS_WORKFLOW.index(new_enum)
    
    if new_index < current_index:
        raise InvalidStatusTransitionError(current_status, new_status)

# CREATE Task
@router.post('/', response_model=TaskOut, status_code=201)
def create_task(task_data: TaskCreate, db: Session = Depends(get_db)):
    try:
        validate_task_data(task_data)
        
        task = Task(**task_data.model_dump())
        db.add(task)
        db.commit()
        db.refresh(task)
        return task
        
    except (EmptyTitleError, InvalidStatusError):
        db.rollback()
        raise
    except IntegrityError:
        db.rollback()
        raise DatabaseError("task creation - possible duplicate or constraint violation")
    except SQLAlchemyError:
        db.rollback()
        raise DatabaseError("task creation")
    except Exception:
        db.rollback()
        raise

# GET Tasks
@router.get("/", response_model=List[TaskOut])
def get_tasks(
    db: Session = Depends(get_db),
    task_id: Optional[int] = Query(default=None, description='Optional Task ID to fetch a specific task'),
    status: Optional[str] = Query(default=None, description='Filter by status'),
    skip: int = Query(0, ge=0, description='Number of records to skip'),
    limit: int = Query(100, ge=1, le=1000, description='Number of records to return')
):
    try:
        # Validate status filter using our custom validation
        if status:
            validate_status_value(status)
        
        if task_id:
            task = db.query(Task).filter(Task.id == task_id).first()
            if not task:
                raise TaskNotFoundError(task_id)
            return [task]
        
        query = db.query(Task)
        if status:
            query = query.filter(Task.status == status)
        
        tasks = query.order_by(Task.id).offset(skip).limit(limit).all()
        
        if not tasks and (task_id is not None or status is not None):
            raise TaskNotFoundError(task_id if task_id else 0)
            
        return tasks
        
    except (TaskNotFoundError, InvalidStatusError):
        raise
    except SQLAlchemyError:
        raise DatabaseError("fetching tasks")
    except Exception:
        raise

# UPDATE Task
@router.put("/{task_id}", response_model=TaskOut)
def update_task(task_id: int, update_data: TaskUpdate, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise TaskNotFoundError(task_id)
        
        if update_data.title is not None:
            if not update_data.title.strip():
                raise EmptyTitleError()
            if len(update_data.title.strip()) > 200:
                raise InvalidStatusError(
                    "Title too long", 
                    ["Title must be less than 200 characters"]
                )
        
        if update_data.status is not None and update_data.status != task.status:
            validate_status_transition(task.status, update_data.status)
        
        update_dict = update_data.model_dump(exclude_unset=True)
        for key, value in update_dict.items():
            setattr(task, key, value)
        
        db.commit()
        db.refresh(task)
        return task
        
    except (TaskNotFoundError, EmptyTitleError, InvalidStatusError, InvalidStatusTransitionError):
        db.rollback()
        raise
    except IntegrityError:
        db.rollback()
        raise DatabaseError("task update - possible constraint violation")
    except SQLAlchemyError:
        db.rollback()
        raise DatabaseError("task update")
    except Exception:
        db.rollback()
        raise

# DELETE Task
@router.delete("/{task_id}", status_code=200)
def delete_task(task_id: int, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise TaskNotFoundError(task_id)
        
        db.delete(task)
        db.commit()
        return {
            "success": True,
            "message": f"Task with ID {task_id} deleted successfully."
        }
        
    except TaskNotFoundError:
        db.rollback()
        raise
    except SQLAlchemyError:
        db.rollback()
        raise DatabaseError("task deletion")
    except Exception:
        db.rollback()
        raise



from sqlalchemy import Column, Integer, String, Boolean, DateTime, CheckConstraint
from sqlalchemy.sql import func
from app.database.database import Base
from app.utils.enums import TaskStatus

class Task(Base):
    __tablename__ = "tasks"

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    title = Column(String(200), index=True, nullable=False)
    description = Column(String(1000), nullable=True)
    completed = Column(Boolean, default=False)
    status = Column(String(20), default=TaskStatus.NOT_STARTED.value, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    __table_args__ = (
        CheckConstraint(
            f"status IN ('{TaskStatus.NOT_STARTED.value}', '{TaskStatus.PENDING.value}', '{TaskStatus.IN_PROGRESS.value}', '{TaskStatus.COMPLETED.value}')",
            name='valid_status_check'
        ),
        CheckConstraint(
            "length(trim(title)) > 0",
            name='non_empty_title_check'
        ),
    )


from pydantic import BaseModel, Field, validator
from typing import Optional
from datetime import datetime
from app.utils.enums import TaskStatus, validate_status_value
from app.exceptions.handlers import InvalidStatusError, EmptyTitleError

class TaskBase(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    status: str = Field(default="not_started")

    @validator('status')
    def validate_status(cls, v):
        if v is None:
            return TaskStatus.NOT_STARTED.value
        
        # Use our custom validation with custom error messages
        try:
            validate_status_value(v)
            return v
        except InvalidStatusError:
            # Re-raise to maintain custom error message
            raise

    @validator('title')
    def validate_title(cls, v):
        if not v or not v.strip():
            raise EmptyTitleError()
        return v.strip()

class TaskCreate(TaskBase):
    pass

class TaskUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    completed: Optional[bool] = None
    status: Optional[str] = None

    @validator('status')
    def validate_status(cls, v):
        if v is None:
            return None
        
        try:
            validate_status_value(v)
            return v
        except InvalidStatusError:
            raise

    @validator('title')
    def validate_title(cls, v):
        if v is not None:
            if not v.strip():
                raise EmptyTitleError()
            return v.strip()
        return v

class TaskOut(TaskBase):
    id: int
    completed: bool
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True



from enum import Enum
from typing import List
from app.exceptions.handlers import InvalidStatusError

class TaskStatus(str, Enum):
    NOT_STARTED = "not_started"
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"

STATUS_WORKFLOW: List[TaskStatus] = [
    TaskStatus.NOT_STARTED,
    TaskStatus.PENDING,
    TaskStatus.IN_PROGRESS,
    TaskStatus.COMPLETED
]

def validate_status_value(status_value: str) -> TaskStatus:
    try:
        return TaskStatus(status_value)
    except ValueError:
        valid_values = [status.value for status in TaskStatus]
        raise InvalidStatusError(status_value, valid_values)
