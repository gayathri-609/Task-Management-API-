from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session
from app.database.database import get_db
from app.schemas.schemas import TaskCreate, TaskUpdate, TaskOut
from app.models.models import Task
from typing import List, Optional

router = APIRouter()

STATUS_FLOW = ["not_started", "pending", "in_progress", "completed"]


# ✅ CREATE Task
@router.post("/", response_model=TaskOut, status_code=201)
def create_task(task_data: TaskCreate, db: Session = Depends(get_db)):
    try:
        # Validate status
        if task_data.status not in STATUS_FLOW:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid status value. Allowed values are: {', '.join(STATUS_FLOW)}"
            )

        # Create new task
        task = Task(**task_data.model_dump())
        db.add(task)
        db.commit()
        db.refresh(task)
        return task

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An unexpected error occurred while creating the task. Please try again later."
        )


# ✅ GET & GET BY ID Combined
@router.get("/", response_model=List[TaskOut])
def get_tasks(
    db: Session = Depends(get_db),
    task_id: Optional[int] = Query(default=None, description="Optional Task ID to fetch a specific task")
):
    try:
        if task_id:
            task = db.query(Task).filter(Task.id == task_id).first()
            if not task:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail=f"No task found with ID {task_id}."
                )
            return [task]  # returning a list for consistent response_model type

        tasks = db.query(Task).order_by(Task.id).all()
        if not tasks:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="No tasks available."
            )
        return tasks

    except HTTPException as e:
        raise e
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Unable to fetch tasks. Please try again later."
        )


# ✅ UPDATE Task (with cyclic flow validation)
@router.put("/{task_id}", response_model=TaskOut)
def update_task(task_id: int, update_data: TaskUpdate, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Task with ID {task_id} not found."
            )

        # Enforce cyclic flow if status is being updated
        if update_data.status:
            current_status = task.status
            new_status = update_data.status

            if current_status not in STATUS_FLOW or new_status not in STATUS_FLOW:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid status. Allowed values are: {', '.join(STATUS_FLOW)}"
                )

            current_index = STATUS_FLOW.index(current_status)
            new_index = STATUS_FLOW.index(new_status)

            if new_index < current_index:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid status transition. Cannot move backward from '{current_status}' to '{new_status}'."
                )

        update_dict = update_data.model_dump(exclude_unset=True)
        for key, value in update_dict.items():
            setattr(task, key, value)

        db.commit()
        db.refresh(task)
        return task

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Something went wrong while updating the task. Please try again later."
        )


# ✅ DELETE Task
@router.delete("/{task_id}", status_code=200)
def delete_task(task_id: int, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Task with ID {task_id} not found."
            )

        db.delete(task)
        db.commit()
        return {"message": f"Task with ID {task_id} deleted successfully."}

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete the task due to an internal error. Please try again later."
        )