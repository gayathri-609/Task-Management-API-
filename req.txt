from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session
from app.database.database import get_db
from app.schemas.schemas import TaskCreate, TaskUpdate, TaskOut
from app.models.models import Task
from typing import List, Optional

router = APIRouter()

STATUS_FLOW = ["not_started", "pending", "in_progress", "completed"]

# ✅ Helper response methods
def success_response(data=None, message=None):
    return {"success": True, "data": data, "message": message}

def error_response(message, code=status.HTTP_400_BAD_REQUEST):
    raise HTTPException(status_code=code, detail={"success": False, "error": message})


# ✅ CREATE Task
@router.post("/", response_model=dict, status_code=201)
def create_task(task_data: TaskCreate, db: Session = Depends(get_db)):
    try:
        if task_data.status not in STATUS_FLOW:
            error_response(
                f"Invalid status value. Allowed values are: {', '.join(STATUS_FLOW)}",
                status.HTTP_400_BAD_REQUEST
            )

        task = Task(**task_data.model_dump())
        db.add(task)
        db.commit()
        db.refresh(task)
        return success_response(data=task, message="Task created successfully.")

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        error_response(
            "An unexpected error occurred while creating the task. Please try again later.",
            status.HTTP_500_INTERNAL_SERVER_ERROR
        )


# ✅ GET & GET BY ID (Combined)
@router.get("/", response_model=dict)
def get_tasks(db: Session = Depends(get_db),
              task_id: Optional[int] = Query(default=None, description="Optional Task ID to fetch a specific task")):
    try:
        if task_id:
            task = db.query(Task).filter(Task.id == task_id).first()
            if not task:
                error_response(f"No task found with ID {task_id}", status.HTTP_404_NOT_FOUND)
            return success_response(data=task)

        tasks = db.query(Task).order_by(Task.id).all()
        if not tasks:
            error_response("No tasks available", status.HTTP_404_NOT_FOUND)
        return success_response(data=tasks)

    except HTTPException as e:
        raise e
    except Exception:
        error_response(
            "Unable to fetch tasks. Please try again later.",
            status.HTTP_500_INTERNAL_SERVER_ERROR
        )


# ✅ UPDATE Task (Cyclic Status Flow)
@router.put("/{task_id}", response_model=dict)
def update_task(task_id: int, update_data: TaskUpdate, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            error_response(f"Task with ID {task_id} not found.", status.HTTP_404_NOT_FOUND)

        # Enforce cyclic flow if status is being updated
        if update_data.status:
            current_status = task.status
            new_status = update_data.status

            if current_status not in STATUS_FLOW or new_status not in STATUS_FLOW:
                error_response(
                    f"Invalid status. Allowed values are: {', '.join(STATUS_FLOW)}",
                    status.HTTP_400_BAD_REQUEST
                )

            current_index = STATUS_FLOW.index(current_status)
            new_index = STATUS_FLOW.index(new_status)

            if new_index < current_index:
                error_response(
                    f"Invalid status transition. Cannot move backward from '{current_status}' to '{new_status}'.",
                    status.HTTP_400_BAD_REQUEST
                )

        update_dict = update_data.model_dump(exclude_unset=True)
        for key, value in update_dict.items():
            setattr(task, key, value)

        db.commit()
        db.refresh(task)
        return success_response(data=task, message="Task updated successfully.")

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        error_response(
            "Something went wrong while updating the task. Please try again later.",
            status.HTTP_500_INTERNAL_SERVER_ERROR
        )


# ✅ DELETE Task
@router.delete("/{task_id}", response_model=dict, status_code=200)
def delete_task(task_id: int, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            error_response(f"Task with ID {task_id} not found.", status.HTTP_404_NOT_FOUND)

        db.delete(task)
        db.commit()
        return success_response(message=f"Task with ID {task_id} deleted successfully.")

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        error_response(
            "Failed to delete task due to an internal error. Please try again later.",
            status.HTTP_500_INTERNAL_SERVER_ERROR
        )