from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Sessin
from app.database.database import get_db
from app.schemas.schemas import TaskCreate, TaskUpdate, TaskOut
from app.models.models import Task
from typing import List, Optional

router = APIRouter()

STATUS_FLOW = ["not_started", "pending", "in_progress", "completed"]


# ✅ CREATE Task
@router.post("/", response_model=TaskOut, status_code=201)
def create_task(task_data: TaskCreate, db: Session = Depends(get_db)):
    try:
        # Validate status
        if task_data.status not in STATUS_FLOW:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid status value. Allowed values are: {', '.join(STATUS_FLOW)}"
            )

        # Create new task
        task = Task(**task_data.model_dump())
        db.add(task)
        db.commit()
        db.refresh(task)
        return task

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An unexpected error occurred while creating the task. Please try again later."
        )


# ✅ GET & GET BY ID Combined
@router.get("/", response_model=List[TaskOut])
def get_tasks(
    db: Session = Depends(get_db),
    task_id: Optional[int] = Query(default=None, description="Optional Task ID to fetch a specific task")
):
    try:
        if task_id:
            task = db.query(Task).filter(Task.id == task_id).first()
            if not task:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail=f"No task found with ID {task_id}."
                )
            return [task]  # returning a list for consistent response_model type

        tasks = db.query(Task).order_by(Task.id).all()
        if not tasks:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="No tasks available."
            )
        return tasks

    except HTTPException as e:
        raise e
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Unable to fetch tasks. Please try again later."
        )


# ✅ UPDATE Task (with cyclic flow validation)
@router.put("/{task_id}", response_model=TaskOut)
def update_task(task_id: int, update_data: TaskUpdate, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Task with ID {task_id} not found."
            )

        # Enforce cyclic flow if status is being updated
        if update_data.status:
            current_status = task.status
            new_status = update_data.status

            if current_status not in STATUS_FLOW or new_status not in STATUS_FLOW:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid status. Allowed values are: {', '.join(STATUS_FLOW)}"
                )

            current_index = STATUS_FLOW.index(current_status)
            new_index = STATUS_FLOW.index(new_status)

            if new_index < current_index:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid status transition. Cannot move backward from '{current_status}' to '{new_status}'."
                )

        update_dict = update_data.model_dump(exclude_unset=True)
        for key, value in update_dict.items():
            setattr(task, key, value)

        db.commit()
        db.refresh(task)
        return task

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Something went wrong while updating the task. Please try again later."
        )


# ✅ DELETE Task
@router.delete("/{task_id}", status_code=200)
def delete_task(task_id: int, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Task with ID {task_id} not found."
            )

        db.delete(task)
        db.commit()
        return {"message": f"Task with ID {task_id} deleted successfully."}

    except HTTPException as e:
        raise e
    except Exception:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete the task due to an internal error. Please try again later."

        )



# app/exceptions/handlers.py
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from typing import Any, Dict

class CustomHTTPException(Exception):
    def __init__(self, status_code: int, detail: str, headers: Dict[str, Any] = None):
        self.status_code = status_code
        self.detail = detail
        self.headers = headers

class TaskNotFoundError(CustomHTTPException):
    def __init__(self, task_id: int):
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Task with ID {task_id} not found."
        )

class InvalidStatusTransitionError(CustomHTTPException):
    def __init__(self, current_status: str, new_status: str):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f'Invalid status transition. Cannot move backward from "{current_status}" to "{new_status}"'
        )

class InvalidStatusError(CustomHTTPException):
    def __init__(self, status_value: str, allowed_values: list):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid status value '{status_value}'. Allowed values are: {', '.join(allowed_values)}"
        )

class EmptyTitleError(CustomHTTPException):
    def __init__(self):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Title cannot be empty or contain only whitespace"
        )

class DatabaseError(CustomHTTPException):
    def __init__(self, operation: str):
        super().__init__(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Database error during {operation}. Please try again later."
        )

def setup_exception_handlers(app: FastAPI):
    
    @app.exception_handler(CustomHTTPException)
    async def custom_http_exception_handler(request: Request, exc: CustomHTTPException):
        return JSONResponse(
            status_code=exc.status_code,
            content={
                "success": False,
                "error": {
                    "code": exc.__class__.__name__,
                    "message": exc.detail,
                    "path": request.url.path
                }
            },
            headers=exc.headers
        )
    
    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        errors = []
        for error in exc.errors():
            errors.append({
                "field": " -> ".join(str(loc) for loc in error['loc']),
                "message": error['msg'],
                "type": error['type']
            })
        
        return JSONResponse(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            content={
                "success": False,
                "error": {
                    "code": "VALIDATION_ERROR",
                    "message": "Request validation failed",
                    "details": errors
                }
            }
        )
    
    @app.exception_handler(SQLAlchemyError)
    async def sqlalchemy_exception_handler(request: Request, exc: SQLAlchemyError):
        # Log the actual error for debugging
        print(f"Database error: {str(exc)}")
        
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "success": False,
                "error": {
                    "code": "DATABASE_ERROR",
                    "message": "A database error occurred",
                    "path": request.url.path
                }
            }
        )
    
    @app.exception_handler(IntegrityError)
    async def integrity_error_handler(request: Request, exc: IntegrityError):
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content={
                "success": False,
                "error": {
                    "code": "INTEGRITY_ERROR",
                    "message": "Data integrity violation (e.g., duplicate entry, foreign key constraint)",
                    "path": request.url.path
                }
            }
        )
    
    @app.exception_handler(500)
    @app.exception_handler(Exception)
    async def general_exception_handler(request: Request, exc: Exception):
        # Log the full exception for debugging
        print(f"Unexpected error: {str(exc)}")
        
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "success": False,
                "error": {
                    "code": "INTERNAL_SERVER_ERROR",
                    "message": "An unexpected error occurred",
                    "path": request.url.path
                }
            }
        )


# app/database/database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.exc import SQLAlchemyError
from app.config.settings import settings
from app.exceptions.handlers import DatabaseError
import logging

logger = logging.getLogger(__name__)

SQLALCHEMY_DATABASE_URL = settings.DATABASE_URL

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, 
    connect_args={"check_same_thread": False},
    pool_pre_ping=True,  # Check connection before using
    echo=settings.DEBUG   # Log SQL queries in debug mode
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
        db.commit()
    except SQLAlchemyError as e:
        logger.error(f"Database error: {str(e)}")
        db.rollback()
        raise DatabaseError("database operation") from e
    except Exception as e:
        logger.error(f"Unexpected error in database session: {str(e)}")
        db.rollback()
        raise
    finally:
        db.close()


# app/models/models.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, CheckConstraint
from sqlalchemy.sql import func
from app.database.database import Base

class Task(Base):
    __tablename__ = "tasks"

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    title = Column(String(200), index=True, nullable=False)  # Added length constraint
    description = Column(String(1000), nullable=True)  # Added length constraint
    completed = Column(Boolean, default=False)
    status = Column(String(20), default="pending", nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    # Database-level constraints
    __table_args__ = (
        CheckConstraint(
            "status IN ('not_started', 'pending', 'in_progress', 'completed')",
            name='valid_status_check'
        ),
        CheckConstraint(
            "length(trim(title)) > 0",
            name='non_empty_title_check'
        ),
    )




# app/routers/tasks.py
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from app.database.database import get_db
from app.schemas.schemas import TaskCreate, TaskUpdate, TaskOut
from app.models.models import Task
from app.exceptions.handlers import (
    TaskNotFoundError, InvalidStatusTransitionError, 
    InvalidStatusError, EmptyTitleError, DatabaseError
)
from typing import List, Optional
import logging

logger = logging.getLogger(__name__)

router = APIRouter()

STATUS_FLOW = ["not_started", "pending", "in_progress", "completed"]

def validate_task_data(task_data: TaskCreate) -> None:
    """Validate task data before database operations"""
    # Title validation
    if not task_data.title or not task_data.title.strip():
        raise EmptyTitleError()
    
    # Title length validation
    if len(task_data.title.strip()) > 200:
        raise InvalidStatusError(
            "Title too long", 
            ["Title must be less than 200 characters"]
        )
    
    # Status validation
    if task_data.status and task_data.status not in STATUS_FLOW:
        raise InvalidStatusError(task_data.status, STATUS_FLOW)

def validate_status_transition(current_status: str, new_status: str) -> None:
    """Validate status transition follows the correct flow"""
    if new_status not in STATUS_FLOW:
        raise InvalidStatusError(new_status, STATUS_FLOW)
    
    current_index = STATUS_FLOW.index(current_status)
    new_index = STATUS_FLOW.index(new_status)
    
    if new_index < current_index:
        raise InvalidStatusTransitionError(current_status, new_status)

# CREATE Task
@router.post('/', response_model=TaskOut, status_code=201)
def create_task(task_data: TaskCreate, db: Session = Depends(get_db)):
    try:
        # Validate input data
        validate_task_data(task_data)
        
        # Create new task
        task = Task(**task_data.model_dump())
        db.add(task)
        db.commit()
        db.refresh(task)
        
        logger.info(f"Task created successfully with ID: {task.id}")
        return task
        
    except (EmptyTitleError, InvalidStatusError):
        db.rollback()
        raise
    except IntegrityError as e:
        db.rollback()
        logger.error(f"Integrity error while creating task: {str(e)}")
        raise DatabaseError("task creation - possible duplicate or constraint violation")
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Database error while creating task: {str(e)}")
        raise DatabaseError("task creation")
    except Exception as e:
        db.rollback()
        logger.error(f"Unexpected error while creating task: {str(e)}")
        raise

# GET Tasks
@router.get("/", response_model=List[TaskOut])
def get_tasks(
    db: Session = Depends(get_db),
    task_id: Optional[int] = Query(default=None, description='Optional Task ID to fetch a specific task'),
    status: Optional[str] = Query(default=None, description='Filter by status'),
    skip: int = Query(0, ge=0, description='Number of records to skip'),
    limit: int = Query(100, ge=1, le=1000, description='Number of records to return')
):
    try:
        # Validate status filter if provided
        if status and status not in STATUS_FLOW:
            raise InvalidStatusError(status, STATUS_FLOW)
        
        if task_id:
            task = db.query(Task).filter(Task.id == task_id).first()
            if not task:
                raise TaskNotFoundError(task_id)
            return [task]
        
        # Build query with filters
        query = db.query(Task)
        if status:
            query = query.filter(Task.status == status)
        
        tasks = query.order_by(Task.id).offset(skip).limit(limit).all()
        
        if not tasks and (task_id is not None or status is not None):
            raise TaskNotFoundError(task_id if task_id else 0)
            
        return tasks
        
    except (TaskNotFoundError, InvalidStatusError):
        raise
    except SQLAlchemyError as e:
        logger.error(f"Database error while fetching tasks: {str(e)}")
        raise DatabaseError("fetching tasks")
    except Exception as e:
        logger.error(f"Unexpected error while fetching tasks: {str(e)}")
        raise

# UPDATE Task
@router.put("/{task_id}", response_model=TaskOut)
def update_task(task_id: int, update_data: TaskUpdate, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise TaskNotFoundError(task_id)
        
        # Validate title if provided
        if update_data.title is not None:
            if not update_data.title.strip():
                raise EmptyTitleError()
            if len(update_data.title.strip()) > 200:
                raise InvalidStatusError(
                    "Title too long", 
                    ["Title must be less than 200 characters"]
                )
        
        # Validate status transition if status is being updated
        if update_data.status is not None and update_data.status != task.status:
            validate_status_transition(task.status, update_data.status)
        
        # Update task
        update_dict = update_data.model_dump(exclude_unset=True)
        for key, value in update_dict.items():
            setattr(task, key, value)
        
        db.commit()
        db.refresh(task)
        
        logger.info(f"Task with ID {task_id} updated successfully")
        return task
        
    except (TaskNotFoundError, EmptyTitleError, InvalidStatusError, InvalidStatusTransitionError):
        db.rollback()
        raise
    except IntegrityError as e:
        db.rollback()
        logger.error(f"Integrity error while updating task {task_id}: {str(e)}")
        raise DatabaseError("task update - possible constraint violation")
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Database error while updating task {task_id}: {str(e)}")
        raise DatabaseError("task update")
    except Exception as e:
        db.rollback()
        logger.error(f"Unexpected error while updating task {task_id}: {str(e)}")
        raise

# DELETE Task
@router.delete("/{task_id}", status_code=200)
def delete_task(task_id: int, db: Session = Depends(get_db)):
    try:
        task = db.query(Task).filter(Task.id == task_id).first()
        if not task:
            raise TaskNotFoundError(task_id)
        
        db.delete(task)
        db.commit()
        
        logger.info(f"Task with ID {task_id} deleted successfully")
        return {
            "success": True,
            "message": f"Task with ID {task_id} deleted successfully."
        }
        
    except TaskNotFoundError:
        db.rollback()
        raise
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Database error while deleting task {task_id}: {str(e)}")
        raise DatabaseError("task deletion")
    except Exception as e:
        db.rollback()
        logger.error(f"Unexpected error while deleting task {task_id}: {str(e)}")
        raise


# app/main.py
import uvicorn
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from app.config.settings import settings
from app.database.database import Base, engine, get_db
from app.routers import tasks
from app.models.models import Task
from app.exceptions.handlers import setup_exception_handlers
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Create database tables
try:
    Base.metadata.create_all(bind=engine)
    logging.info("Database tables created successfully")
except Exception as e:
    logging.error(f"Failed to create database tables: {str(e)}")
    raise

app = FastAPI(
    title=settings.APP_NAME,
    version=settings.API_VERSION,
    debug=settings.DEBUG
)

# Setup exception handlers
setup_exception_handlers(app)

# Include router
app.include_router(
    tasks.router,
    prefix=f"/api/{settings.API_VERSION}/tasks",
    tags=["Tasks"]
)

@app.get("/health")
def health_check():
    return {
        "success": True,
        "status": "ok", 
        "message": "FastAPI server is running",
        "version": settings.API_VERSION
    }

@app.get("/")
def get_all_tasks(db: Session = Depends(get_db)):
    try:
        tasks = db.query(Task).all()
        return {
            "success": True,
            "data": tasks if tasks else [],
            "message": "No tasks found. Add some using /docs or /tasks" if not tasks else "Tasks retrieved successfully"
        }
    except Exception as e:
        logging.error(f"Error in root endpoint: {str(e)}")
        return {
            "success": False,
            "error": "Failed to fetch tasks",
            "data": []
        }

if __name__ == "__main__":
    uvicorn.run(
        app, 
        host="0.0.0.0", 
        port=8000,
        log_level="info"
    )
